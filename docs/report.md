# I. XPUSH 와 API 소개

## 1.1 소개 

XPUSH는 eXtended Push의 약자이며, 대용량 분산 환경에서 실시간으로 데이터 송수신을 처리하기 위하여 개발되었다. MIT 라이선스(MIT License) 오픈소스로 누구라도 무상으로 취급 및 사용이 가능하다.

실시간으로 즉시 데이터를 송수신 해야하는 요구는 채팅, 실시간 상황판, 모바일 알림 등 다양한 영역에 걸쳐 존재하며, 실제로 게임에서 복수의 캐릭터의 동작이나 화면을 동기화 하는데 사용되거나, 채팅에서의 메시지 발송 및 수신 등에서 많이 활용되고 있다.

실시간 데이터 통신을 위해서는 아래와 같은 기능들이 필요하다.
- 데이터 송수신, 데이터 저장 및 조회
- 접속 사용자 및 Device 관리
- 접속을 위한 인증 처리 및 Session 관리

XPUSH는 이러한 필수적인 기능들을 모아 별도의 서버로 구축하여 플랫폼화한 것이다. 이러한 플랫폼을 기반으로 다양한 실시간 서비스를 쉽고 빠르게 개발하도록 하는 것이 본 프로젝트의 목표이다.

플랫폼에 구현된 기능들은 필수 기능과 서비스 기능으로 구분되어 있다.
필수 기능은 모든 서비스에 공통적으로 사용될 수 있는, 서비스에 종속되지 않은 기능이고, 
서비스 기능은 플랫폼에 영향을 주지 않는 각각의 서비스에 해당하는 기능이다.

## 1.2 XPUSH 구성요소


## 1.3 XPUSH 설치



# II. XPUSH 기술 동향

## 1.1 WebSocket을 이용한 실시간 데이터 처리

과거의 실시간 데이터 처리는 아래의 방식으로 이루어지고 있었다.

### 1.1.1 폴링(Polling) 방식 
브라우저가 일정한 주기로 HTTP로 요청을 보내는 방식으로, 실시간 데이터의 업데이트 주기를 예측하기 어렵기 때문에 불필요한 서버 요청이 다수 발생할 수 있다. 메시지가 갱신되는 기간을 정확히 알수 있는 경우에는 적합하지만 채팅같이 임의로 발생하는 경우에는 적합하지 않다.

### 1.1.2. 롱폴링(Long Polling) 방식
HTTP 요청 시 서버는 해당 요청을 일정 시간 동안 대기 시킨다. 대기 시간 안에 데이터가 업데이트되었다면, 클라이언트에게 응답을 보내고 서버로 재요청을 시작한다. 일정 시간 동안 메시지가 발생하지 않으면 응답을 보내고 다시 요청받는다. 데이터의 업데이트가 빈번하거나 데이터가 큰 경우 폴링에 비해 성능상 이점이 크지 않다.

### 1.1.3. 스트리밍 방식
서버는 지속적인 업데이트를 위하 무한정 요청을 대기시키며, 연결을 유지시킨다. 이에 데이터 전송 과정에서 불필요한 많은 양의 오버헤드를 발생시키며, 대기시간에 따른 성능저하가 발생한다.

### 1.1.4. WebSocket의 등장

HTTP프로토콜의 경우 연결을 유지하지 않는 특성때문에 10번 요청을 보내면 10번 연결을 맺고 끊는 과정이 필요하기 때문에, 모든 요청에 헤더가 들어가게 되어서 낭비가 발생할 수 있다. WebSocket은 HTTP와 달리 첫 연결 후 지속적으로 연결이 유지되기 때문에 불필요한 오버헤드가 적게 발생하며, 양방향으로 통신이 가능하기 때문에 대기시간이 필요하지 않다.

## 1.2 이벤트 기반 프레임워크 nodejs

10k 프라플럼을 해결하기 위해서는 주요 병목 구간을 파악해야하는데, 대부분의 경우 IO나 Network Access에서 많은 비용이 발생하게 된다. 서버가 IO 처리를 하다가 지연이 발생하면 다른 요청들은 처리되지 못하고 대기하게 되는데, 이러한 문제를 위해 비동기 방식의 프로그램이 등장하게 되었다.

### 1.2.1. Nodejs의 비동기 처리
Nodejs 는 Google Chrome의 V8 엔진 기반으로 동작하는 단일 쓰레드(Single-Thread)의 비동기 네트워크 서버이다.  이벤트 루핑(Event Looping)을 이용하여 요청을 처리하는 도중 다른 요청을 받을 수 있으며, 요청이 완료된 후 Callback을 요청하여 처리 완료가 완료되었음을 알린다. 수많은 작업을 병렬처리 할 수 있도록 설계되어 있기 때문에, 수많은 클라이언트가 사용하는 채팅이나 메신져, FIDS 등의 서버에 최적화되어 있다고 할 수 있다.

### 1.2.3 io.js 의 등장
node.js TJ Fontain이 3대 리더를 맡은 2013년 이후 1년 이상 새버전이 릴리즈가 안되고 이슈가 처리가 안되는 현상이 있었다. 더 큰 문제는 언제 릴리즈될지 어떤 문제가 있고 어떻게 해결할 것인지에 대한 내용이 커뮤니티와 전혀 의사소통이 되지 않고 있었던 것이다. 이 과정에서 node의 핵심 컨트리뷰터였던 node와는 다른 운영방식을 통해 node의 이슈들을 해결하고자 하는 취지르 io.js 가 탄생하게 되었다. 기존의 node 가 Joyent라는 특정 회사에 속해 있던 것에 반해 오픈 거버넌스 모델로 운영하면서 투명하게 합의를 이루어 나가는 것이었다. 실제로 io.js가 성능 측정 결과 13% 정도 퍼포먼스가 더 뛰어남이 벤치마크 결과에서 나타나면서 node.js를 강력하게 위협하게 되었다. 실제로 nodejs의 최신 버젼이 0.12 버젼에서 머무는 동안에  io.js 는 1.0을 릴리즈하였다.

### 1.2.4 io.js와의 재통합

이렇게 분리하여 나가던 두 프로젝트는 2015년 5월 중순 node.js와 io.js의 커뮤니티들이 노드JS 재단(Noje.js Foundation)이라는 이름하에 서로 협력해 코드를 통합하기로 발표하였다. Joyent 라는 특정 회사의 소속이 아닌 재단이름 하에 개발을 이어나가기로 결정한 것이다. 이 이후 2015년 9월 8일  io.js 와 node.js 프로젝트가 결합되어 4.0.0 Stable 버전이 릴리즈되었다. 기존의 node.js는 0.X 버젼을 사용하고 있었고, io.js 는 3.x 버젼을 사용하고 있었기 때문에 충돌을 피하고자 4.0 버젼으로 출발하게 된 것이다.

v.0.12 에서 4.0.0 으로 바뀌면서 변화된 주요 내용은 아래와 같다.

#### 새로운 V8 Version
- 현재 크롬브라우져에서 사용 중인 V8 v4.5가 포함되어 되었다.
- 화살표 함수 등의 새로운 ES6 기능이 기본적으로 활성화되었다.

#### LTS와 정기 릴리즈 주기
장기지원(LTS)과 정기 릴리즈주기가 생겼다. 릴리즈 버젼은 [SeemVer](http://semver.org/lang/ko/)의 룰을 따르며 6개월마다 새로운 stable 버젼을 위한 브랜치가 생성된다. LTS 버젼은 12개월마다 정기적으로 릴리즈 되며, 차기 버젼 릴리즈 후에 18개월 동안 관리된 이후에 unstable 버젼으로 돌아가는 방식이다. 이러한 LTS 버젼은 릴리즈 날부터 30개월 ( 12 + 18 )간 관리되기 때문에 운영환경에서 사용하기에 적합한 버젼이라고 할 수 있다.


참조

- http://cyberx.tistory.com/28
- http://mohwaproject.tistory.com/114
- http://www.websocket.org/quantum.html
- http://www.nextree.co.kr/p7292/
- http://bcho.tistory.com/
- http://blog.outsider.ne.kr/1102